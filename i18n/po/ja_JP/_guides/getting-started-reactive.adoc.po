# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2021-01-27 17:23+0000\n"
"PO-Revision-Date: 2021-02-03 19:51+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: \n"
"Language-Team: \n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-reactive.adoc:6
#, no-wrap
msgid "Quarkus - Getting started with Reactive"
msgstr "Quarkus: Reactive の使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:12
msgid "Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:"
msgstr "Quarkus でリアクティブアプリケーションを作成し、Quarkus が提供するさまざまなリアクティブ機能を確認する方法を説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:14
msgid "A quick glance at the Quarkus engine and how it enables reactive"
msgstr "Quarkus エンジンのクイック範囲と、リアクティブの有効化方法"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:15
msgid "A brief introduction to Mutiny - the reactive programming library used by Quarkus"
msgstr "Mutiny の概要 - Quarkus で使用されるリアクティブプログラミングライブラリー"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:16
msgid "The difference between RESTEasy, RESTEasy Reactive and Reactive Routes"
msgstr "RESTEasy、RESTEasy Reactive および Reactive ルートの違い"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:17
msgid "The bootstrap of a reactive application using RESTEasy Reactive"
msgstr "RESTEasy Reactive を使用したリアクティブアプリケーションのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:18
msgid "Creating a reactive JAX-RS endpoint (asynchronous, streams...)"
msgstr "リアクティブ JAX-RS エンドポイントの作成（非同期、ストリーム）"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:19
msgid "Using reactive database access"
msgstr "リアクティブデータベースアクセスの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:20
msgid "Interacting with other reactive APIs"
msgstr "他のリアクティブ API との対話"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:21
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:24
msgid "To complete this guide, you need:"
msgstr "本ガイドを完了するには、以下が必要です。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:26
msgid "less than 15 minutes"
msgstr "15 分未満"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:27
msgid "an IDE"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:28
msgid "JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately"
msgstr "適切に設定された `JAVA_HOME` でインストールされた JDK 8 または 11+"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:29
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:30
#, no-wrap
msgid "Solutions"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:33
msgid ""
"We recommend that you follow the instructions from <<bootstrapping-the-project,Bootstrapping project>> and onwards to create the application step by "
"step."
msgstr "ステップごとにアプリケーションを作成するために、 link:#bootstrapping-the-project[Bootstrapping project] の手順に従うことが推奨されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:35
msgid "However, you can go right to the completed example."
msgstr "ただし、完全な例に近いものにすることができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:37
msgid "Download an {quickstarts-archive-url}[archive] or clone the git repository:"
msgstr "{quickstarts-archive-url}[archive] をダウンロードするか、git リポジトリーのクローンを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:41
#, no-wrap
msgid "git clone {quickstarts-clone-url}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:44
msgid "The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories."
msgstr "このソリューションは、 `getting-started-reactive` および `getting-started-reactive-crud` ディレクトリーにあります。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:45
#, no-wrap
msgid "The multiple reactive facets of Quarkus"
msgstr "Quarkus の複数のリアクティブファー"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:51
msgid ""
"Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x "
"(https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine."
msgstr ""
"Quarkus はリアクティブで、誠実な状態でも、Quarkus アプリケーションの電源にリアクティブエンジンが置かれます。このエンジンは、Eclipse Vert.x（https://"
"vertx.io）で、ブロックなしおよびリアクティブの Vert.x エンジンを介してすべてのネットワーク I/O を渡します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:53
msgid "image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]"
msgstr "image:quarkus-reactive-stack.png[alt=\"Quarkus are based on a reactive engine\", height=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:61
msgid ""
"Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request "
"and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the "
"routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  "
"The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that "
"thread."
msgstr ""
"動作について説明するには、2 つの例を見てみましょう。 受信 HTTP リクエストを生成します。 Quarkus に埋め込まれた(Vert.x)HTTP サーバー(Vert.x)はリクエストを"
"受信し、これをアプリケーションにルーティングします。 リクエストが _imperative_ メソッド(*raditional JAX-RS)をターゲットにし、 `@Blocking` … のアノテー"
"ションが付けられたコードは _worker_ スレッドでリソースメソッドを呼び出します。 ここまでの新規または未処理のことはありません。 以下は、この動作を示してい"
"ます。 この場合、アプリケーションコードはワーカースレッドで呼び出され、ビジネスロジックはそのスレッドをブロックできます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:63
msgid "image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]"
msgstr "image:http-blocking-sequence.png[alt=\"Behavior when using the imperative routes\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:65
msgid ""
"But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with "
"`@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:"
msgstr ""
"ただし、HTTP リクエストがリアクティブメソッドをターゲットにする場合（RESTEasy Reactive、リアクティブルート、 `@Incoming` メソッドを使用した JAX-RS は、 "
"`@Blocking` … アノテーションが付けられた I/O スレッド上のルートを呼び出します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:67
msgid "image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]"
msgstr "image:http-reactive-sequence.png[alt=\"Behavior when using the reactive routes\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:74
msgid ""
"Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource "
"utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as "
"the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the "
"thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread."
msgstr ""
"Quarkus は I/O スレッドを使用してコードを呼び出すため、context-switches を保存し、スレッドプール管理を回避します。これにより、リソースの使用率が改善され"
"ます。 ただし、コードは、スレッドの *NOT* ブロックである必要があります。 なぜですか？ I/O スレッドは複数の同時リクエストを処理するために使用されます。 一"
"部の I/O の実行に必要なため、要求の処理が進捗できないと、これらの I/O がスケジュールされ、連携を渡します。 別のリクエストを処理できるスレッドを解放しま"
"す。 スケジュールされた I/O が完了すると、調整が実行され、I/O スレッド上で再度実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:78
msgid ""
"As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application "
"services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be "
"written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon."
msgstr ""
"そのため、多くの Quarkus コンポーネントは、データベースアクセス（PostgreSQL、MySQL、Mongo など）、アプリケーションサービス（メール、テンプレートエンジン"
"など）、メッセージング（Kafka、AMQP など）といったリアクティブで設計されます。また、このモデルを完全に活用するには、アプリケーションコードはブロック以外"
"の方法で記述する必要があります。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:80
#, no-wrap
msgid "Mutiny - A reactive programming library"
msgstr "mutiny - リアクティブプログラミングライブラリー"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:84
msgid ""
"https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers "
"two types:"
msgstr "link:[Mutiny, タブレット=\"\"] は、非同期アクションを表現および作成するリアクティブプログラミングライブラリーです。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:86
msgid "`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result"
msgstr "`io.smallrye.mutiny.Uni` - 0 または 1 つの結果を提供する非同期アクションの場合"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:87
msgid "`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams"
msgstr "`io.smallrye.mutiny.Multi` - マルチアイテム（バックフィルあり）ストリーム"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:90
msgid ""
"Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists)."
msgstr "この計算はどちらも Lazy で、サブスクリプションパターンに従い、サブスクリプションパターンに従います（つまり、サブスクライバーの登録など）。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:97
#, no-wrap
msgid ""
"uni.subscribe().with(\n"
"    result -> System.out.println(\"result is \" + result),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:102
#, no-wrap
msgid ""
"multi.subscribe().with(\n"
"    item -> System.out.println(\"Got \" + item),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:108
msgid ""
"Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided "
"into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations "
"are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable "
"API, and the result does not require too much knowledge around reactive."
msgstr ""
"`Uni` および `Multi` はイベント駆動型の API を公開します。イベント駆動型の API を公開します（success、fail など）。 これらの API はグループ（操作のタイ"
"プ）に分割され、1 つのクラスにメソッド 100 が割り当てられないようにします。 主な操作には、障害、完了、操作、およびそれらを抽出または収集することに関する"
"主な操作が含まれます。 ネスト化可能な API により、スムーズなコーディングエクスペリエンスが得られます。そのため、リアクティブに関する知識はそれほど必要あ"
"りません。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:113
#, no-wrap
msgid ""
"httpCall\n"
"    .onFailure().recoverWithItem(\"my fallback\");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:119
msgid ""
"You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the "
"Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are "
"interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more "
"complex."
msgstr ""
"Reactive Streams(https://www.reactive-streams.org/). `Multi` については、Reactive Streams を確認してください(https://www.reactive-streams.org/)。 "
"Reactive Streams `=6` を実装するため、Reactive Streams のバックレートメカニズムを実装します。 `Uni` は、結果のサブスクリプションとして `Uni` を実装するだ"
"けではありません。 Reactive Streams の subscription/request ceremony がより複雑であるため、これは単純な API とスムーズな API の概念に重点を置いています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:122
msgid ""
"Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For "
"example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`."
msgstr ""
"Quarkus からのリアクティブおよび命令の固定（ `Uni` および `Multi` の両方）は、命令構造のブリッジを提供します。 たとえば、 `Multi` を `Iterable` または "
"_await_ に変換することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:127
#, no-wrap
msgid ""
"// Block until the result is available\n"
"String result = uni.await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:130
#, no-wrap
msgid ""
"// Transform an asynchronous stream into a blocking iterable\n"
"stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:134
msgid ""
"At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny "
"allows converting `Unis` and `Multis` from and to RX Java and Reactor types:"
msgstr ""
"この時点では、RxJava または Reactor ユーザーであれば、よく知られている `Flowable` 、 `Single` 、 `Flux` の使用方法に直面する可能性があります。 , `Mono` "
"… Mutiny では、 `Unis` および `Multis` から RX Java および Reactor タイプへ変換できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:139
#, no-wrap
msgid ""
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:144
msgid "But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:"
msgstr "ただし、Vert.x は、Vert.x API も Mutiny タイプを使用して利用できます。以下のスニペットは、Vert.x Web クライアントの使用を示しています。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:164
#, no-wrap
msgid ""
"// Use io.vertx.mutiny.ext.web.client.WebClient\n"
"client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"// ...\n"
"Uni<JsonObject> uni =\n"
"    client.get(\"/api/fruit/\" + name)\n"
"        .send()\n"
"        .onItem().transform(resp -> {\n"
"            if (resp.statusCode() == 200) {\n"
"                return resp.bodyAsJsonObject();\n"
"            } else {\n"
"                return new JsonObject()\n"
"                        .put(\"code\", resp.statusCode())\n"
"                        .put(\"message\", resp.bodyAsString());\n"
"            }\n"
"        });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:167
msgid ""
"Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so "
"on in your reactive pipeline."
msgstr ""
"最後に、Mutiny には MicroProfile Context Propagation との組み込み統合があり、トランザクションを伝播、トレース性データなどのリアクティブパイプラインで対応"
"できます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:169
msgid "But enough talking, let's get our hands dirty!"
msgstr "しかし、十分だとお考えになることはありません。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:170
#, no-wrap
msgid "Bootstrapping the project"
msgstr "プロジェクトのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:175
msgid ""
"There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of "
"RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread."
msgstr ""
"本ガイドでは、Quarkus でリアクティブアプリケーションを実装する方法がいくつかあります。本書では、RESTEasy Reactive を使用して、Quarkus リアクティブエンジ"
"ンから RESTEasy を活用しています。デフォルトでは、I/O スレッドで HTTP エンドポイントを呼び出します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:178
msgid ""
"While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked "
"on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose."
msgstr ""
"_traditional_ RESTEasy を使用することは可能ですが、 `quarkus-resteasy-mutiny` 拡張を追加する必要があり、メソッドは引き続き _worker_ スレッドで呼び出され"
"ます。 したがって、リアクティブプログラミングを使用しますが、ワーカースレッドが必要なため、目的は限定されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:180
msgid "The easiest way to create a new Quarkus project is to open a terminal and run the following command:"
msgstr "新しい Quarkus プロジェクトを作成するための最も簡単な方法として、ターミナルを開き、以下のコマンドを実行します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:182
msgid "For Linux and macOS users"
msgstr "Linux および macOS ユーザーの場合"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:192
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive \\\n"
"    -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"resteasy-reactive\"\n"
"cd getting-started-reactive\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:195
msgid "For Windows users"
msgstr "Windows ユーザーの場合"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:197
msgid "If using cmd, (don't use forward slash `\\`)"
msgstr "cmd を使用する場合、（don' はスラッシュ `\\` を使用しません）"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:201
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:204
msgid "If using Powershell, wrap `-D` parameters in double quotes"
msgstr "Powershell を使用する場合は、 `-D` パラメーターを二重引用符で囲みます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:208
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.getting.started.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:211
msgid "It generates the following in `./getting-started-reactive`:"
msgstr "以下を `./getting-started-reactive` で生成します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:213
msgid "the Maven structure"
msgstr "Maven の構造"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:214
msgid "an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`"
msgstr "`org.acme.quickstart.ReactiveGreetingResource` リソースで ` /hello` に公開される `org.acme.quickstart.ReactiveGreetingResource` リソース"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:215
msgid "an associated unit test"
msgstr "関連するユニットテスト"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:216
msgid "a landing page that is accessible on `http://localhost:8080` after starting the application"
msgstr "アプリケーションの起動後、 `http://localhost:8080` でアクセス可能なランディングページ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:217
msgid "example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`"
msgstr "例 `Dockerfile` （ `native` および `jvm` モード）の `src/main/docker` ファイルの例"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:218
msgid "the application configuration file"
msgstr "アプリケーション設定ファイル"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:219
#, no-wrap
msgid "Reactive JAX-RS resources"
msgstr "リアクティブ JAX-RS リソース"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:222
msgid ""
"During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:"
msgstr "プロジェクトの作成時に、 `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` ファイルが以下の内容で作成されている。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:226 upstream/_guides/getting-started-reactive.adoc:269 upstream/_guides/getting-started-reactive.adoc:291
#, no-wrap
msgid "package org.acme.getting.started;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:231
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:234 upstream/_guides/getting-started-reactive.adoc:304
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:241
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello RESTEasy Reactive\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:245
msgid ""
"It's a very simple REST endpoint, returning \"Hello RESTEasy Reactive\" to requests on \"/hello\".  As it uses RESTEAsy Reactive, this method is called "
"on the I/O thread."
msgstr ""
"これは非常にシンプルな REST エンドポイントであり、\"Hello RESTEasy Reactive\" を \"/hello\" 上で返しています。RESTEAsy Reactive を使用するため、このメ"
"ソッドは I/O スレッドで呼び出されます。"

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:250
msgid ""
"To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use "
"`@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:"
msgstr ""
"_worker_ スレッド上でこのメソッドを呼び出すよう Quarkus に指示するには、 `io.smallrye.common.annotation.Blocking` アノテーションでアノテーションを付けま"
"す。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:256
#, no-wrap
msgid ""
"import javax.ws.rs.ApplicationPath;\n"
"import javax.ws.rs.core.Application;\n"
"import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:261
#, no-wrap
msgid ""
"@ApplicationPath(\"/\")\n"
"@Blocking\n"
"public class RestBlockingApplication extends Application {\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:265
msgid "Let's now create a `ReactiveGreetingService` class with the following content:"
msgstr "次に、以下の内容で `ReactiveGreetingService` クラスを作成してください。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:272
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:275
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:278
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveGreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:284
#, no-wrap
msgid ""
"    public Uni<String> greeting(String name) {\n"
"        return Uni.createFrom().item(name)\n"
"                .onItem().transform(n -> String.format(\"hello %s\", n));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:287
msgid "Then, edit the `ReactiveGreetingResource` class to match the following content:"
msgstr "次に、 `ReactiveGreetingResource` クラスを編集して、以下の内容に一致させます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:297
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:301
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:307
#, no-wrap
msgid ""
"    @Inject\n"
"    ReactiveGreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:314
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"/greeting/{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return service.greeting(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:321
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:326
msgid ""
"The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted "
"immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide."
msgstr ""
"`ReactiveGreetingService` クラスには `Uni` を生成するシンプルなメソッドが含まれます。しかし、この例では、この項目はすぐに生成され、 `Uni` を生成するシン"
"プルなメソッドが含まれます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:328
msgid "Now, start the application using:"
msgstr "ここで、以下のコマンドを使用してアプリケーションを起動します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:332
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:335
msgid "Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo."
msgstr "実行したら、 link:[http://localhost:8080/hello/greeting/neo, マーカーのクラス=\"bare\"] を開いて、予想される greeting メッセージを取得します。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:336
#, no-wrap
msgid "Handling streams"
msgstr "ストリームの処理"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:340
msgid ""
"So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could "
"come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages."
msgstr "これまでは非同期結果のみが返されました。本セクションでは、複数の項目をストリームでアプリケーションを拡張します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:342
msgid "In the `ReactiveGreetingService`, add the following method:"
msgstr "`ReactiveGreetingService` に以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:350
#, no-wrap
msgid ""
"public Multi<String> greetings(int count, String name) {\n"
"  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .onItem().transform(n -> String.format(\"hello %s - %d\", name, n))\n"
"        .transform().byTakingFirstItems(count);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:353
msgid "you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements."
msgstr "`import io.smallrye.mutiny.Multi;` および `import java.time.Duration;` ステートメントを追加する必要がある場合があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:355
msgid "It generates a greeting message every second and stops after `count` messages."
msgstr "これは 1 秒ごとに greeting メッセージを生成し、 `count` メッセージの後に停止します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:357
msgid "In the `ReactiveGreetingResource` add the following method:"
msgstr "`ReactiveGreetingResource` に以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:366
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Path(\"/greeting/{count}/{name}\")\n"
"public Multi<String> greetings(int count, String name) {\n"
"  return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:370
msgid "This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters."
msgstr ""
"このエンドポイントは、JSON アレイとしてイベントをクライアントにストリーミングします。メッセージの名前と数は、path パラメーターを使用してパラメーターされ"
"ます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:372
msgid "So calling the endpoint produces something like:"
msgstr "エンドポイントを呼び出すと、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:377
#, no-wrap
msgid ""
"$ curl http://localhost:8080/hello/greeting/3/neo\n"
"[\"hello neo - 0\", \"hello neo - 1\", \"hello neo - 2\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:380
msgid "We can also generate Server-Sent Event responses by returning a `Multi`:"
msgstr "また、 `Multi` を返すことで、Server-Sent Event の応答を生成することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:390
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestSseElementType(MediaType.TEXT_PLAIN)\n"
"@Path(\"/stream/{count}/{name}\")\n"
"public Multi<String> greetingsAsStream(int count, String name) {\n"
"    return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:394
msgid ""
"The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the "
"`@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event."
msgstr ""
"以前のスニペットとの唯一の相違点は生成されたタイプで、 `@RestSseElementType` アノテーションは各イベントのタイプを示す `@Produces` アノテーションを定義す"
"るため、 `SERVER_SENT_EVENTS` は各イベントのタイプを認識している必要があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:396
msgid "You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement."
msgstr "`import org.jboss.resteasy.reactive.RestSseElementType;` ステートメントを追加する必要がある場合があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:398
msgid "You can see the result using:"
msgstr "以下を使用して結果を確認できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:403
#, no-wrap
msgid ""
"$ curl -N http://localhost:8080/hello/stream/5/neo\n"
"data: hello neo - 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:405
#, no-wrap
msgid "data: hello neo - 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:407
#, no-wrap
msgid "data: hello neo - 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:409
#, no-wrap
msgid "data: hello neo - 3\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:411
#, no-wrap
msgid "data: hello neo - 4\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:413
#, no-wrap
msgid "Using Reactive APIs"
msgstr "リアクティブ API の使用"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:415
#, no-wrap
msgid "Using Quarkus reactive APIs"
msgstr "Quarkus リアクティブ API の使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:419
msgid ""
"Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to "
"interact with your database in a non-blocking and reactive way."
msgstr ""
"Quarkus は、Mutiny モデルを使用して多くのリアクティブ API を提供します。本セクションでは、Reactive PostgreSQL ドライバーを使用して、非ブロッキングおよび"
"リアクティブ方式でデータベースと対話する方法を説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:421
msgid "Create a new project using:"
msgstr "以下を使用して新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:431
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive-crud \\\n"
"    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-reactive,resteasy-reactive-jackson,reactive-pg-client\"\n"
"cd getting-started-reactive-crud\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:434
msgid "This application is interacting with a PostgreSQL database, so you need one:"
msgstr "このアプリケーションは PostgreSQL データベースと対話しているので、以下のものが必要です。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:441
#, no-wrap
msgid ""
"docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n"
"           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n"
"           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n"
"           -p 5432:5432 postgres:11.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:445
msgid "Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:"
msgstr "次に、データソースを設定します。 `src/main/resources/application.properties` を開き、以下の内容を追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:453
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n"
"myapp.schema.create=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:457
msgid ""
"The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the "
"application gets initialized."
msgstr "3 行目はデータソースを定義します。最後の行はアプリケーションで使用され、アプリケーションの初期化時にいくつかの項目を挿入するかどうかを指定します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:460
msgid "Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:"
msgstr "ここで _entity_ を作成します。 `org.acme.reactive.crud.Fruit` クラスを以下の内容で作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:464 upstream/_guides/getting-started-reactive.adoc:538 upstream/_guides/getting-started-reactive.adoc:581
#, no-wrap
msgid "package org.acme.reactive.crud;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:471
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import io.vertx.mutiny.sqlclient.Row;\n"
"import io.vertx.mutiny.sqlclient.RowSet;\n"
"import io.vertx.mutiny.sqlclient.Tuple;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:473
#, no-wrap
msgid "import java.util.stream.StreamSupport;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:475
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:477
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:479
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:483
#, no-wrap
msgid ""
"    public Fruit() {\n"
"        // default constructor.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:487
#, no-wrap
msgid ""
"    public Fruit(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:492
#, no-wrap
msgid ""
"    public Fruit(Long id, String name) {\n"
"        this.id = id;\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:500
#, no-wrap
msgid ""
"    public static Multi<Fruit> findAll(PgPool client) {\n"
"        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute()\n"
"                // Create a Multi from the set of rows:\n"
"                .onItem().transformToMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n"
"                // For each row create a fruit instance\n"
"                .onItem().transform(Fruit::from);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:506
#, no-wrap
msgid ""
"    public static Uni<Fruit> findById(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(RowSet::iterator)\n"
"                .onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:511
#, no-wrap
msgid ""
"    public Uni<Long> save(PgPool client) {\n"
"        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\").execute(Tuple.of(name))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:516
#, no-wrap
msgid ""
"    public Uni<Boolean> update(PgPool client) {\n"
"        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\").execute(Tuple.of(name, id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:521
#, no-wrap
msgid ""
"    public static Uni<Boolean> delete(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:526
#, no-wrap
msgid ""
"    private static Fruit from(Row row) {\n"
"        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:532
msgid ""
"This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as "
"the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` "
"and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects."
msgstr ""
"この _entity_ には、データベースから行を検索、更新、削除するいくつかのフィールドおよびメソッドが含まれています。 これらのメソッドは、結果を取得したときに"
"非同期的に出力されるため、 `Unis` または `Multis` を返します。 リアクティブ PostgreSQL クライアントがすでに `Uni` インスタンスおよび `Multi` インスタンス"
"を提供していることに注意してください。 したがって、データベースから _business-friendly_ オブジェクトに結果のみを変換します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:534
msgid "For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:"
msgstr "アプリケーションの起動時にデータベースを初期化する目的で、以下の内容で `DBInit` という名前のクラスを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:542
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:545
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:548
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class DBInit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:551
#, no-wrap
msgid ""
"    private final PgPool client;\n"
"    private final boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:556
#, no-wrap
msgid ""
"    public DBInit(PgPool client, @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\") boolean schemaCreate) {\n"
"        this.client = client;\n"
"        this.schemaCreate = schemaCreate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:562
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {\n"
"        if (schemaCreate) {\n"
"            initdb();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:573
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:577
msgid "Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:"
msgstr "次に、 `FruitResource` クラスを `FruitResource` でこの `FruitResource` クラスを使用し、 `FruitResource` クラスを編集して以下の内容に一致させます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:583
#, no-wrap
msgid "import java.net.URI;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:595
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.PUT;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.ResponseBuilder;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:599
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:604
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:606
#, no-wrap
msgid "    private final PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:610
#, no-wrap
msgid ""
"    public FruitResource(PgPool client) {\n"
"        this.client = client;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:620
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:625
#, no-wrap
msgid ""
"    @GET\n"
"    public Multi<Fruit> get() {\n"
"        return Fruit.findAll(client);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:633
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> getSingle(Long id) {\n"
"        return Fruit.findById(client, id)\n"
"                .onItem().transform(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n"
"                .onItem().transform(ResponseBuilder::build);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:640
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<Response> create(Fruit fruit) {\n"
"        return fruit.save(client)\n"
"                .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n"
"                .onItem().transform(uri -> Response.created(uri).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:648
#, no-wrap
msgid ""
"    @PUT\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> update(Long id, Fruit fruit) {\n"
"        return fruit.update(client)\n"
"                .onItem().transform(updated -> updated ? Status.OK : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:657
#, no-wrap
msgid ""
"    @DELETE\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> delete(Long id) {\n"
"        return Fruit.delete(client, id)\n"
"                .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:660
msgid "This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class."
msgstr "このリソースは、 `Fruit` クラスによって生成された結果に基づいて `Uni` インスタンスおよび ` インスタンスを返します。`"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:661
#, no-wrap
msgid "Using Vert.x clients"
msgstr "Vert.x クライアントの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:665
msgid "The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly."
msgstr "上記の例では、Quarkus が提供する _service_ を使用します。さらに、Vert.x クライアントを直接使用できます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:667
msgid "First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:"
msgstr "まず、 `quarkus-vertx` 拡張機能が存在することを確認します。そうでない場合は、以下のコマンドを実行してエクステンションを有効にします。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:672
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n"
"    -Dextensions=vertx\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:675
msgid "Or add `quarkus-vertx` into your dependencies manually."
msgstr "または、 `quarkus-vertx` を依存関係に手動で追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:682
#, no-wrap
msgid ""
"<dependency>\n"
"\t<groupId>io.quarkus</groupId>\n"
"\t<artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:686
msgid "There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:"
msgstr "この API は、個別にインポートできるアーティファクトが複数あります。"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:719
#, no-wrap
msgid ""
"|groupId:artifactId | Description\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n"
"|Mutiny API for Vert.x Core\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n"
"|Mutiny API for the Vert.x Mail Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n"
"|Mutiny API for the Vert.x Web Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n"
"|Mutiny API for the Vert.x Mongo Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n"
"|Mutiny API for the Vert.x Redis Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n"
"|Mutiny API for the Vert.x Cassandra Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n"
"|Mutiny API for the Vert.x Consul Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n"
"|Mutiny API for the Vert.x Kafka Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n"
"|Mutiny API for the Vert.x AMQP Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n"
"|Mutiny API for the Vert.x RabbitMQ Client\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:722
msgid "You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/."
msgstr ""
"利用可能な API を確認することもできます。 link:[http://smallrye.io/smallrye-reactive-utils/apidocs/, マーカークラス=\"bare\"] で確認することもできます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:725
msgid "Let's take an example.  Add the following dependency to your application:"
msgstr "以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:732
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:736
msgid "It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:"
msgstr "これは、Vert.x Web クライアントの Mutiny API を提供します。また、以下のように Web クライアントを使用できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:740
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:747
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:754
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:757
#, no-wrap
msgid ""
"@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:760
#, no-wrap
msgid ""
"    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:762
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:769
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:786
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .map(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:788
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:791
msgid "There are 2 important points:"
msgstr "以下の 2 つの重要な点があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:793
msgid "The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;"
msgstr "インジェクトされた Vert.x インスタンスには、Vert.x の Mutiny バリアントである `io.vertx.core.Vertx` 型があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:794
msgid "The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`."
msgstr "Web クライアントは、 `io.vertx.mutiny.ext.web.client.WebClient` から作成されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:796
msgid "The Mutiny version of the Vert.x APIs also offers:"
msgstr "Vert.x API の Mutiny バージョンは以下も提供します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:799
msgid ""
"`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block "
"the event loop / IO thread that way."
msgstr ""
"`andAwait` メソッドは、 `sendAndAwait` などのメソッドです。 `andAwait` は、結果が利用可能になるまで呼び出し元スレッドがブロックされることを示します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:803
msgid ""
"`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the "
"resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be "
"triggered.  `andForget` manages this for you and manage the subscription."
msgstr ""
"`andForget` メソッド（ `writeAndForget` など）。 `andForget` は、 `Uni` を返すメソッドに利用できます。 . `andForget` は、生成される `Uni` は操作の成功ま"
"たは失敗を示す必要がないことを示しています。 ただし、サブスクライブしない場合には操作がトリガーされません。 `andForget` は、サブスクリプションの管理のた"
"めにこれを管理します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:804
msgid "`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`"
msgstr "`toMulti` メソッドにより Vert.x `ReadStream` を `Multi` に変換できるようになります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:805
msgid ""
"`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`"
msgstr "`toBlockingIterable` / `toBlockingStream` メソッドにより、Vert.x `ReadStream` をブロッキングまたはブロッキング `java.util.Stream` に変換できる"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:806
#, no-wrap
msgid "Using RxJava or Reactor APIs"
msgstr "RxJava または Reactor API の使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:809
msgid "Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`."
msgstr "mutiny は、RxJava 2 および Project Reactor タイプを `Uni` および `Multi` に変換するユーティリティーを提供します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:811
msgid "RxJava 2 converters are available in the following dependency:"
msgstr "RxJava 2 コンバーターは、以下の依存関係で利用できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:818
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-rxjava</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:821
msgid ""
"So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as "
"follows:"
msgstr ""
"RxJava 2 タイプを返す API がある場合（ `Completable` 、 `Single` 、 `Maybe` 、 `） Observable` 、 `Flowable` は以下のように `Unis` および `Multis` を作成"
"できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:833
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniRxConverters;\n"
"// ...\n"
"Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n"
"Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n"
"Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n"
"Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n"
"Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n"
"Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:840
#, no-wrap
msgid ""
"Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n"
"Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n"
"Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n"
"Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n"
"Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n"
"Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:843
msgid "You can also transform `Unis` and `Multis` into RxJava types:"
msgstr "`Unis` および `Multis` を RxJava タイプに変換することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:860
#, no-wrap
msgid ""
"Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n"
"Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n"
"Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n"
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n"
"Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n"
"// ...\n"
"Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n"
"Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n"
"Single<String> single2 = multi.convert().with(MultiRxConverters\n"
"        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n"
"Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n"
"Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n"
"Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:863
msgid "Project Reactor converters are available in the following dependency:"
msgstr "Project Reactor コンバーターは、以下の依存関係で利用できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:870
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-reactor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:873
msgid "So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:"
msgstr "そのため、API が Reactor タイプ（ `Mono` 、 `Flux` ）を返す場合は、以下のように `Unis` と `Multis` を作成することができます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:881
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n"
"// ...\n"
"Uni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters.fromMono(), mono);\n"
"Uni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:884
#, no-wrap
msgid ""
"Multi<String> multiFromMono = Multi.createFrom().converter(MultiReactorConverters.fromMono(), mono);\n"
"Multi<String> multiFromFlux = Multi.createFrom().converter(MultiReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:887
msgid "You can also transform `Unis` and `Multis` into Reactor types:"
msgstr "`Unis` および `Multis` を Reactor タイプに変換することもできます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:892
#, no-wrap
msgid ""
"Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\n"
"Flux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:895
#, no-wrap
msgid ""
"Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\n"
"Flux<String> flux2 = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:897
#, no-wrap
msgid "Using CompletionStages or Publisher API"
msgstr "CompletionStages または Aero API の使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:901
msgid ""
"If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` "
"can be created from a `CompletionStage` or from a `Supplier<CompletionStage>`. For example:"
msgstr ""
"`CompletionStage` 、 `CompletableFuture` 、または ` で API を接続する場合は、バックまたは後に変換できます。 まず、Uni および Multi は CompletionStage ま"
"たは から作成できます。 以下に例を示します。`"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:907
#, no-wrap
msgid ""
"CompletableFuture<String> future = Uni\n"
"        // Create from a Completion Stage\n"
"        .createFrom().completionStage(CompletableFuture.supplyAsync(() -> \"hello\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:910
msgid ""
"On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or "
"failure emitted by the `Uni`."
msgstr ""
"`Uni` に `CompletionStage` を生成する `subscribeAsCompletionStage（）` を生成することもできます。 `Uni` によって出力されたアイテムまたは失敗を取得する"
"コード>CompletionStage。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:914
msgid ""
"You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a "
"`Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`."
msgstr ""
"`Unis` および `Multis` のインスタンスから `createFrom` を作成することもできます。 `toMulti` を使用して `Uni` を `toMulti` に変換できます。 indeed, "
"`Multi` implements `‍` ."

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:915
#, no-wrap
msgid "What's next?"
msgstr "次は何ですか？"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:920
msgid ""
"This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a "
"few examples:"
msgstr "本ガイドでは、Quarkus のリアクティブで、すでにリアクティブされている Quarkus 機能が多数あります。以下のリストは、いくつかの例を示しています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:922
msgid "link:rest-json#reactive[Using Mutiny with RestEasy]"
msgstr "link:rest-json#reactive[Using Mutiny with RestEasy]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:923
msgid "link:mailer[Sending email]"
msgstr "link:mailer[Sending email]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:924
msgid "link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]"
msgstr "link:mongodb#reactive[Using MongoDB] および MongoDB with Panache"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:925
msgid "link:reactive-sql-clients[Reactive Database Clients]"
msgstr "link:[Reactive Database Clients, ~]#=\"reactive-sql-clients\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:926
msgid "link:vertx[Using Vert.x]"
msgstr "link:[Using Vert.x, ~]#=\"vertx\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:927
msgid "link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"
msgstr "link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:neo4j#reactive[Using Neo4J]"
msgstr "link:[Using Neo4J, ~]#=\"neo4j#reactive\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:reactive-routes[Using reactive routes]"
msgstr "link:[Using reactive routes, ~]#=\"reactive-routes\"]"

#, fuzzy
#~ msgid "The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy Jackson to serialize payloads."
#~ msgstr "生成された `pom.xml` はまた、ペイロードをシリアライズするために RESTEasy Mutiny サポートと RESTEasy Jackson を宣言しています。"

#, fuzzy
#~ msgid ""
#~ "In order to get Mutiny working properly with JAX-RS resources, make sure the Mutiny support for RESTEasy extension (`io.quarkus:quarkus-resteasy-"
#~ "mutiny`) is present, otherwise add the extension by executing the following command:"
#~ msgstr ""
#~ "JAX-RSリソースでMutinyを正しく動作させるためには、RESTEasyエクステンションのMutinyサポート( `io.quarkus:quarkus-resteasy-mutiny`)が存在することを確認"
#~ "してください。"

#, fuzzy
#~ msgid "Or add `quarkus-resteasy-reactive` into your dependencies manually."
#~ msgstr "または、手動で `quarkus-resteasy-mutiny` を依存関係に追加してください。"
